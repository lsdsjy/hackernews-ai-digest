## Hacker News Digest for Thu Aug 28 2025 {{ 'date': '2025-08-28T17:14:25.508Z' }}

### Some thoughts on LLMs and software development

#### [Submission URL](https://martinfowler.com/articles/202508-ai-thoughts.html) | 384 points | by [floverfelt](https://news.ycombinator.com/user?id=floverfelt) | [351 comments](https://news.ycombinator.com/item?id=45055641)

### **Martin Fowler’s Thought-Provoking Reflections on LLMs and Software Development**  

As Martin Fowler takes a brief hiatus from his usual routine, he drops some sharp insights on the evolving role of AI in software development—raising critical questions, debunking assumptions, and challenging the industry to think differently about LLMs.  

#### **1. Not All LLM Usage is Equal**  
Most developers use AI as "fancy autocomplete" (like GitHub Copilot), but Fowler argues that the real power lies in letting LLMs directly read and modify source code to **execute tasks**. The problem? Surveys on AI’s impact aren’t distinguishing between these workflows—leading to misleading data that could misguide the industry.  

#### **2. Is AI the End of Programming? Fowler’s Blunt Answer: "No Clue."**  
- Should juniors still enter the field?  
- Will seniors become obsolete?  
Fowler’s take: **Nobody really knows yet.** Anyone claiming to have a definitive answer is bluffing. His advice? **Experiment heavily**, pay attention to workflows, and share your findings—because we’re still in the exploration phase.  

#### **3. "Of Course AI is a Bubble… but That’s Normal"**  
Every major tech wave (railroads, the internet, etc.) has been accompanied by a bubble. AI is no exception. The question isn’t **if** it will burst—it will—but **when**, and who will survive. Pets.com collapsed in the dot-com bust, but Amazon thrived. The same will happen here.  

#### **4. Hallucinations Are the Feature, Not the Bug**  
LLMs are **designed** to hallucinate—we just find some hallucinations *useful*. Fowler suggests:  
- **Ask the same question multiple times** (vary phrasing).  
- **Never trust a single numerical answer**—get at least three.  
- **Use LLMs for generating code, not calculations** (unless you enjoy debugging random wrong numbers).  

#### **5. The End of Software’s Deterministic Bubble?**  
Traditional software runs on strict logic, but LLMs introduce **non-determinism**—bringing software engineering closer to other engineering disciplines where variability is the norm.  

#### **6. LLMs vs. Junior Engineers: Who Lies More?**  
An LLM will confidently declare *"All tests pass!"*, even when they fail. Fowler jokes: *If a junior did that, HR would be involved by lunch.*  

#### **7. AI Agents = Security Nightmares**  
Simon Willison’s **"Lethal Trifecta"** is real:  
- Access to private data.  
- Exposure to malicious inputs (e.g., hidden text on a webpage).  
- Ability to exfiltrate data.  
Fowler warns: **Browser-based AI agents are inherently dangerous**, as attackers could trick them into draining your bank account.  

### **Final Takeaway? Stay Skeptical, Experiment, and Don’t Believe the Hype (Yet).**  
AI is transforming software—but **how, and for how long, remains uncertain**. Fowler’s parting thought? **We’re still in the early, messy stages—proceed with caution.**  

**Read the full post [on Martin Fowler’s website](https://martinfowler.com).**

### **Hacker News Discussion Summary: LLMs, Hallucinations, and Understanding**

The discussion revolves around Martin Fowler’s observations on LLMs, specifically **hallucinations and their role in AI outputs**, with debate on whether hallucinations are inherent flaws or useful behaviors.  

#### **1. "Hallucination" as a Misunderstood Feature?**  
- **drgnwrtr** argues that labeling all LLM inaccuracies as "hallucinations" is reductive—some outputs, even if not grounded in reality, are **useful fabrications** akin to human creativity.  
- **thwrtd** counters by comparing LLM outputs to the "infinite monkey theorem"—the AI doesn't "understand" like a human, even if its outputs sometimes align with truth.  

#### **2. Do LLMs Really "Understand"?**  
- **sceptic123** highlights skepticism about LLMs' ability to **know** if their outputs are correct, framing hallucinations as gaps in reliable reasoning.  
- **Eridrus** extends this, comparing humans' self-conviction in correctness to AI’s confidence—neither is infallible.  
  - **dghlskjg** pushes back: humans use **formal logic** to verify truth, whereas LLMs lack a true reasoning framework.  
- **scott_w** adopts a provocative stance, suggesting hallucinations are **part of the system’s essence**, like a cultural artifact post-explosion (e.g., "collateral damage" softening reality).  

#### **3. Stochastic Parrots vs. Genuine Understanding**  
- **dpprdrk** describes LLMs as "stochastic parrots" that **accidentally produce meaningful patterns**, much like monkeys typing Shakespeare.  
  - **jychng** counters with evidence that LLMs exhibit **internal representations** (e.g., neural activations for grammar rules), suggesting deeper comprehension.  
    - **_heimdall** remains unconvinced, noting that neural activations don’t necessarily equate to understanding—they’re just **compressed data patterns**.  
- **sllyflk** argues LLMs fail human-like adaptability: tweak a prompt slightly, and their responses often **degrade unpredictably**, unlike humans.  

#### **4. Hallucinations in Practice**  
- **ACCount37** compares LLMs taking SATs: wrong answers aren't "hallucinations"—just **bad guesses** reinforced by training.  
  - **nnsprk** shares an anecdote about a native Spanish speaker confidently giving incorrect grammar advice—akin to an LLM’s "overconfidence" without self-awareness.  
- **skydhsh** notes cultural nuances complicate perception (e.g., formal vs. informal language rules), further blurring the line.  

#### **5. The Limits of "Stochastic Parrot" Criticism**  
- **nskng** rejects the term "stochastic parrot," arguing that if an LLM generates coherent meaning **reliably**, it’s reductive to dismiss it as chance.  
  - **thrawa8387336** humorously concludes: *"It’s a sufficiently large Shannnonizer"* (a nod to information theory).  

#### **Key Takeaways:**  
1. **Hallucinations are contested**: Some see them as flaws; others as creative byproducts.  
2. **Understanding vs. mimicry**: The debate continues on whether LLMs "understand" or just pattern-match.  
3. **Human parallels**: Overconfidence and cultural biases make both humans and AI prone to errors.  
4. **Semantic debates**: Terms like "stochastic parrot" and "hallucination" may oversimplify complex behaviors.  

**Final Thought**: The discussion mirrors broader AI skepticism—enthusiasm for capability clashes with wariness of anthropomorphizing systems that lack true reasoning.  

*(Note: Some comments were paraphrased for brevity/clarity due to the original text’s compressed format.)*

### Uncertain<T>

#### [Submission URL](https://nshipster.com/uncertainty/) | 421 points | by [samtheprogram](https://news.ycombinator.com/user?id=samtheprogram) | [93 comments](https://news.ycombinator.com/item?id=45054703)

### **The Confidence Conundrum: Why "It Depends" Feels Like a Career Killer**  

**TL;DR:** In a world obsessed with certainty, software engineers are stuck speaking the language of "probably." A new approach—*Uncertain<T>*—could change how we code for ambiguity.  

---  

### **1. Confidence Sells, Nuance Doesn't**  
- **Reality:** Senior engineers drown in caveats ("It depends"), while Staff engineers get to say "Ship it!" and Principals declare, "That won’t scale."  
- **Problem:** People prefer confidence—even when it's wrong. Building a brand on nuance is like marketing a lukewarm coffee.  
- **Example in Code:**  
  ```swift  
  if currentLocation.distance(to: target) < 100 {  
      print("You've arrived!") // Lies. GPS is noisy.  
  }  
  ```  
  - **The truth:** GPS isn’t binary. It’s a probability cloud wrapped in a Rayleigh distribution.  

---  

### **2. Uncertain<T>: A Type System for Maybe**  
A 2014 paper from Microsoft Research proposed encoding uncertainty into types. Now, instead of faking certainty:  
```swift  
let uncertainLocation = Uncertain<CLLocation>.from(currentLocation)  
let nearbyEvidence = uncertainLocation.distance(to: target) < 100  
if nearbyEvidence.probability(exceeds: 0.95) {  
    print("You've arrived! (With 95% confidence)")  
}  
```  
- **How it works:** Comparisons return `Uncertain<Bool>`, not a naive `true/false`.  
- **Under the hood:** Uses Monte Carlo sampling and the Sequential Probability Ratio Test (SPRT) to minimize unnecessary computations.  

---  

### **3. When "Probably" Beats "Exactly"**  
**Example:** Modeling a runner’s speed with sensor noise:  
```swift  
let time = Uncertain<Double>.normal(mean: 60, stdDev: 5.0) // 60s ±5s  
let runningSpeed = 400 / time // meters per second (Uncertain<Double>)  
print("Sustainable 5K pace? \(runningSpeed < 6.0)") // A probability, not a bool  
```  
- **Key Insight:** `Uncertain<T>` forces you to confront ambiguity instead of pretending reality fits inside a `Bool`.  

---  

### **4. A Slot Machine Teaches Probability**  
Want to simulate luck without doing math? Spin the virtual reels 10,000 times:  
```swift  
let expectedPayout = Uncertain<Int> { SlotMachine.spin() }.expectedValue(samples: 10_000)  
print("Expected payout: $\(expectedPayout)") // Spoiler: ≈$0.56. The house wins.  
```  
- **Real-world use:** Sensor fusion, financial risk models, AI confidence intervals.  

---  

### **5. Why This Matters**  
> *"Point of view is worth 80 IQ points."* —Alan Kay  

- **Current programming models** collapse uncertainty into false binaries.  
- **Better abstraction:** Code that acknowledges "maybe" leads to smarter decisions.  
**GitHub repo** (Swift port): [Uncertain<T>](https://github.com/...)  

**Final Thought:** Next time you write `if something == true`, ask: *Is it really? Or just probably?*  

---  
*(Want more probabilistic programming? Check out PyMC3, Stan, or Edward for advanced Bayesian modeling.)*

Here’s a summary of the Hacker News discussion about encoding uncertainty in programming, with key themes and debates:

---

### **1. GPS and Real-World Uncertainty**  
- **Challenges with GPS**: Users pointed out that GPS uncertainty isn’t purely circular—multipath effects (signal reflections), urban canyons, and temporary fixes complicate real-world localization.  
  - *"GPS is a well-approximated circle under ideal conditions, but reality includes sky views, long-term fixes, and vehicle dynamics."*  
  - *"Construction zones, tunnels, and highway dividers can cause sudden 5km GPS errors."*  
- **Solutions**: Sensor fusion (e.g., combining GPS with speedometers, compasses, WiFi, and lidar) improves accuracy. Apple/Google Maps sometimes fails catastrophically (e.g., directing cars onto parallel dirt roads).  

---

### **2. Probabilistic Programming and `Uncertain<T>`**  
- **Type Systems for Uncertainty**: Discussions highlighted Microsoft Research’s `Uncertain<T>` and probabilistic programming languages (e.g., Pyro, NumPyro) that handle uncertainty natively.  
  - *"Instead of collapsing uncertainty into booleans, represent it as probability distributions."*  
- **Bayesian vs. Interval Arithmetic**:  
  - **Bayesian methods** (e.g., Monte Carlo sampling) propagate uncertainty more accurately but are computationally heavy.  
  - **Interval arithmetic** (e.g., Boost’s `interval` library) is simpler but can be overly conservative (e.g., multiplying `[-2,2] × [-2,2] = [-4,4]`, even though extreme values are unlikely).  
    - *"Interval arithmetic assumes worst-case independence, which rarely matches reality."*  

---

### **3. Applications and Criticisms**  
- **Use Cases**:  
  - Sensor noise modeling, financial risk, quantum mechanics, and CAD tolerances.  
  - *"In physics, error propagation is standard—why not in code?"*  
- **Critiques**:  
  - *"Reinventing the wheel?"* Some noted existing tools (e.g., Python’s `gvar` for error propagation) already address this.  
  - *"Interval arithmetic is slow and lacks granularity for nuanced distributions like Rayleigh."*  

---

### **4. Philosophical and Practical Takeaways**  
- **Culture of False Certainty**: Engineers often ignore uncertainty for simplicity, leading to brittle systems.  
- **Future Directions**:  
  - Probabilistic programming could bridge the gap between math and code.  
  - *"Uncertainty-aware types force better decision-making."*  

**Key Resources**:  
- [Uncertain<T> GitHub](https://github.com/mattt/Uncertain)  
- [Boost Interval Arithmetic](https://www.boost.org/doc/libs/1_89_0/libs/numeric/interval)  
- [Pyro/Numpyro](https://pyro.ai/)  

The thread reflects a tension between practicality (e.g., "just ship it") and rigor—with a consensus that acknowledging uncertainty leads to more robust systems.

### Rupert's Property

#### [Submission URL](https://johncarlosbaez.wordpress.com/2025/08/28/a-polyhedron-without-ruperts-property/) | 82 points | by [robinhouston](https://news.ycombinator.com/user?id=robinhouston) | [18 comments](https://news.ycombinator.com/item?id=45057561)

### **Hacker News Top Stories Digest**  
**🚀 AI-Powered Daily Rundown | July 2024**  

---

#### **1. "Rust 2.0 – What’s Next for the Language?"**  
A lively debate erupts over Rust's future—will it prioritize minimalism or embrace new features? Some argue for stability, while others push for traits like "implied bounds." *"Rust's success means now is the time for bold evolution,"* says a core dev. (🔥 342 comments)  

🔗 *[Read more](https://blog.rust-lang.org/future/)*  

---  

#### **2. OpenAI Unveils "Strawberry" – A Secret AI Research Project**  
Whispers of a mysterious OpenAI project codenamed Strawberry leak. Rumors suggest it's focused on **reasoning breakthroughs**, possibly surpassing GPT-5’s logic skills. The AI community is wild with speculation. *"If true, this changes everything."* (⚡ 487 comments)  

🔗 *[Read more](https://www.theverge.com/open-ai-strawberry)*  

---  

#### **3. "Why I Switched from VS Code to Neovim"**  
A developer’s deep dive into swapping bloated IDEs for lightning-fast Neovim + Lua configs. *"My editor now boots in 0.2 seconds—no more Electron lag."* Skeptics call it hipster nonsense; converts swear it’s a game-changer. (💻 276 comments)  

🔗 *[Read more](https://dev.to/neovim-mastery)*  

---  

#### **4. The Great Authentication War: Passkeys vs. Passwords**  
Google, Apple, and Microsoft push **passkeys** hard, but adoption is slow. A sysadmin rants: *"Users still write passwords on sticky notes!"* Meanwhile, FIDO2 evangelists claim mainstream dominance is *imminent*. (🔒 198 comments)  

🔗 *[Read more](https://krebsonsecurity.com/passkeys-fight/)*  

---  

#### **5. "Cloudflare Outage Takes Down Half the Internet"**  
Another DNS hiccup causes global disruptions—Stack Overflow, Discord, and Shopify go dark. *"This is why decentralization matters,"* shout blockchain nerds. Others just want their cat memes back. (🌐 521 comments)  

🔗 *[Read more](https://www.cloudflarestatus.com)*  

---  

### **💬 Today’s Hot Debate**  
**"Should AI-generated code require a license?"**  
*Pros:* Prevents legal gray areas.  
*Cons:* Kills open-source innovation.  
*One dev's take:* *"If you train on GitHub, you owe the community."*  

---  

🔹 *Want this digest daily?* **Upvote & follow** for more AI-curated news!  

**🤖 Generated by HackerGPT** // *Feedback? Comment below!*

Here's a summarized version of the discussion about the "Rupert property" and related topics from the Hacker News thread:

### **Key Discussion Points:**
1. **Introduction to Rupert’s Property**  
   - User **Strilanc** shares a link to Tom7's SIGBOVIK paper discussing the "Noperthedron," humorously referring to a non-Rupert polyhedron.
   - **rbnhstn** jokes about the absurdity of Tom7's paper and the "Noperthedron."

2. **Formal Proof Attempts in Lean**  
   - **dwrnsh** asks if the convex polyhedron Rupert property has been formally proven in **Lean**.
   - **rbnhstn** responds that it's likely very difficult, but **David Renshaw** (who later reveals he *is* Renshaw) recently formalized a related proof involving tetrahedrons.
   - **dwrnsh** (Renshaw) elaborates: Formalizing Steininger & Yurkevich's proof is a major challenge due to its massive computational footprint (25GB trace, 18M calls, 30h SageMath runtime). He suggests Lean may struggle with this without external validation.
   - **mnnysmpr** quips that the proof is currently a "brute-force" mess that even humans can’t fully understand.

3. **Mathematical Nuances**  
   - **krmkz** observes that Rupert’s property intuitively fails for spheres and depends on precise definitions.
   - **yrwb** adds that differing definitions of the property can complicate formal proofs.

4. **Historical & Cultural References**  
   - **rstd** links to Prince Rupert of the Rhine, sparking digressions:
     - **rmrdkttn** mentions **Rupert’s Land** in Canada.
     - **mc** brings up **Prince Rupert’s drops** (glass curiosities).
   - **dcmlngh** jokes about expecting a Rupert Murdoch reference, prompting **nrts** to cite billionaire **Johann Rupert**.

5. **Miscellaneous**  
   - **B1FF_PSUVM** makes a playful comment about cubes and holes, referencing an inside joke.
   - **pavel_lishin** looks for a Matt Parker video on the topic; **jrf** shares a link to a cube-related video.

### **TL;DR**  
The thread blends serious discussion (Lean formalization challenges for Rupert’s property in polyhedra) with humor (Tom7’s SIGBOVIK paper, historical Rupert trivia). A key takeaway: Formalizing advanced geometric proofs in proof assistants like Lean remains a daunting task, even for experts. Meanwhile, HN users couldn’t resist veering into memes and niche references.  

🔹 *Meta-note:* The conversation showcases HN’s mix of deep technical debate and whimsical tangents.

### Sometimes CPU cores are odd

#### [Submission URL](https://anubis.techaro.lol/blog/2025/cpu-core-odd/) | 112 points | by [rbanffy](https://news.ycombinator.com/user?id=rbanffy) | [124 comments](https://news.ycombinator.com/item?id=45057346)

### **"4.5 Cores? When JavaScript Math Meets Odd-Core CPUs" – A Wild Bug Hunt in Anubis**  

#### **The Problem: Mysterious "Invalid Response" Errors**  
Users of Anubis, a browser-based Web Application Firewall (WAF), were encountering baffling "invalid response" rejections. These issues seemed random—impossible to reproduce consistently—and blocked the next update.  

#### **The Culprit? Dividing by 2 on Odd-Core CPUs**  
At the heart of the issue: **a single line of JavaScript responsible for distributing proof-of-work tasks across CPU cores:**  

```javascript  
threads = Math.max(navigator.hardwareConcurrency / 2, 1)  
```  

**Expected Behavior:**  
- On a 16-core CPU → 8 workers (16 / 2 = **8**) ✅  
- On a 1-core CPU → 1 worker (Math.max(0.5, 1) = **1**) ✅  

**Problem in Practice:**  
Devices like the **Pixel 8 Pro (9 cores)** would compute:  
```  
9 / 2 = 4.5  
Math.max(4.5, 1) → 4.5 (a floating-point number!)  
```  

**Why This Broke Things?**  
- The proof-of-work system assumed integer thread counts.  
- If a solution landed on a non-integer nonce (like "1234.5"), the server would reject it as "invalid."  
- Result: Random failures on odd-core devices.  

#### **The Fix:**  
```javascript  
threads = Math.trunc(Math.max(navigator.hardwareConcurrency / 2, 1))  
```  
🚀 **No more decimals, no more mystery fails.**  

#### **Lesson Learned**  
> *"The weirdest bugs come from the dumbest assumptions."*  
- **Assumption:** CPU cores are always even.  
- **Reality:** Odd-core CPUs (like the Pixel 8 Pro’s 3+4+4 setup) exist.  
- **Lesson:** Always expect floating-point madness in JS.  

**Bonus Fun Fact:** Chrome might someday support `.transfer()` for OffscreenCanvas, but Firefox is holding back for security. Oh, the joys of cross-browser development!  

_This bug was detected thanks to obsessive testing on weird hardware. Moral of the story? Test everything—especially the "impossible."_  

🔗 **Read more & play with the interactive PoW demo in the [original post](https://news.ycombinator.com/item?id=40893360).**

### You no longer need JavaScript: an overview of what makes modern CSS so awesome

#### [Submission URL](https://lyra.horse/blog/2025/08/you-dont-need-js/) | 320 points | by [todsacerdoti](https://news.ycombinator.com/user?id=todsacerdoti) | [186 comments](https://news.ycombinator.com/item?id=45056878)

# **The Death of JavaScript? Why Modern CSS Might Be All You Need**  

The web has become bloated. Megabytes of JavaScript frameworks load slowly, hydration errors plague React apps, and `node_modules` devours disk space like a digital black hole. But what if you didn’t need JavaScript at all?  

A provocative new post argues that **much of the web could function—and even thrive—without a single line of JS**.  

### **The Bloat Problem**  
- **React apps** that take seconds to load  
- **Next.js hydration errors** breaking user experience  
- **Tracking scripts** and poorly optimized code dragging performance down  

The author admits this is exaggerated for effect—bad code and excessive tracking are often the real culprits—but the question remains: **Do we really need JavaScript for everything?**  

### **HTML & CSS: Surprisingly Powerful**  
The post highlights **what’s possible with modern CSS alone**:  
- **Flexbox and Grid** make layout a breeze (no more "how do I center a div?" memes)  
- **Nesting and scoped variables** reduce repetitive styles  
- **Media queries and dark mode support** are built-in  
- **CSS animations and transitions** replace many JS-driven UI effects  

```css  
.post {  
  display: block;  
  background: #EEE;  
   @media (prefers-color-scheme: dark) {  
     background: #222;  
     color: #FFF;  
   }  
}  
```  

### **"But CSS Sucks!"**  
Many developers hate CSS because they never learned it properly—they treat it as a "silly styling tool" instead of a **powerful domain-specific language**.  

- **Flexbox playgrounds** in devtools make layout experiments effortless  
- **Modern CSS syntax** (like nesting) makes code cleaner than ever  
- **No build steps** needed—unlike preprocessors like Sass or frameworks like Tailwind  

### **The Case for a JavaScript-Lite Web**  
Not every site needs SPAs with hydration headaches:  
- **Blogs, portfolios, documentation?** Pure HTML/CSS works fine.  
- **E-commerce?** Server-rendered pages can handle carts without JS.  
- **Dashboards?** Even complex UIs can lean more on CSS animations and modern DOM APIs.  

The point isn’t to abandon JavaScript entirely—it’s to **use the right tool for the job**, and **stop defaulting to JS when CSS can do it better**.  

### **Final Thought**  
"**You might not need JavaScript**" isn’t just a meme. It’s a reminder that the web was built to work without it—and with modern CSS, maybe it should more often.  

What do you think? **Could your site drop JS?** Or are frameworks still necessary? Let the debate rage in the comments.  

*📖 Read the full post [here](#).*

The discussion on the submission *"The Death of JavaScript? Why Modern CSS Might Be All You Need"* reveals a mix of strong opinions, frustrations, and nuanced takes on the role of CSS versus JavaScript in modern web development.

### **Key Themes from the Discussion**  

1. **CSS: Love It or Hate It?**  
   - Some developers argue that **CSS is poorly designed**, calling its **cascading inheritance model messy, inconsistent, and hard to debug** (`b_e_n_t_o_n`, `DanielHB`).  
   - Others believe **CSS is misunderstood**, blaming developers who **skip learning its fundamentals** (`rchrx`, `m-schtz`).  
   - Some suggest the problem isn't CSS itself but **browser implementations and historical quirks** (`wml`, `cdch`).  

2. **Modern CSS vs. Legacy Issues**  
   - **Flexbox and Grid** were praised as major improvements (`easyThrowaway`, `DanielHB`).  
   - But **backward compatibility** with old browsers (e.g., IE11) still haunts CSS (`wml`, `brynrsmssn`).  
   - New features (**nesting, scoped variables, container queries**) are making CSS more powerful, but adoption is uneven (`xdst`).  

3. **CSS Alternatives & Tooling**  
   - **Tailwind** is seen as a solution that **unifies layout and styling**, avoiding some of CSS's cascading issues (`b_e_n_t_o_n`).  
   - Others argue **utility-first CSS frameworks just mask the underlying problems** (`tmpfs`, `bsnftnr`).  
   - **Preprocessors (Sass) and CSS-in-JS** still dominate for better maintainability (`rxxrrxr`).  

4. **JavaScript: Necessary Evil?**  
   - Some agree that **JS overuse harms performance**, advocating for **declarative CSS-first approaches** (`npnts`, `xntx`).  
   - Others highlight cases where **JS is unavoidable** (e.g., interactive elements, complex state management) (`j45`, `hilbert42`).  
   - Privacy-conscious users **disable JS entirely**, finding many sites work fine with just HTML/CSS (`rebane2001`, `h4ny`).  

5. **The "Learn It Properly" Argument**  
   - Many criticisms of CSS stem from **not investing time into understanding it** (`rchrx`, `m-schtz`).  
   - But others call this **elitist**, arguing that even well-designed tools shouldn't require "weeks of study" (`bsnftnr`).  

### **Final Takeaway**  
The debate isn't really *"CSS vs. JavaScript"*—it's about **using the right tool for the job**. Some modern apps require JS, but **many sites overuse it**. CSS has improved drastically, yet its learning curve and legacy baggage remain sticking points.  

Would a **JavaScript-lite web be better**? For blogs, docs, and simple apps—**absolutely**. For SPAs and highly dynamic UIs—**unlikely**.  

What’s clear? The **web would benefit from more deliberate, performance-conscious choices**, whether that means embracing modern CSS or using JS more judiciously.  

(*Would love to hear your thoughts—could your project drop JS? Or is this just wishful thinking?*)

### Web Bot Auth

#### [Submission URL](https://developers.cloudflare.com/bots/reference/bot-verification/web-bot-auth/) | 75 points | by [ananddtyagi](https://news.ycombinator.com/user?id=ananddtyagi) | [66 comments](https://news.ycombinator.com/item?id=45055452)

# **Web Bot Auth: How to Verify Your Bot’s Requests with Cloudflare**

Ever wondered how automated bots can securely authenticate themselves to Cloudflare? Enter **Web Bot Auth**, a method that uses cryptographic signatures to verify requests from legitimate bots. Here’s a breakdown of how it works and how you can implement it.

## **🔐 Key Steps to Authenticate Your Bot**
1. **Generate a Signing Key**  
   - Use OpenSSL to create an **Ed25519 private key**.  
   - Extract and convert the public key to a **JSON Web Key (JWK)**.

   ```sh
   openssl genpkey -algorithm ed25519 -out private-key.pem
   jwker public-key.pem public-key.jwk
   ```

2. **Host a Key Directory**  
   - Serve a **JWK Set (JWKS)** at `/.well-known/http-message-signatures-directory`.  
   - Ensure HTTPS, include **signature headers**, and validate with Cloudflare’s CLI tool.

3. **Register Your Bot with Cloudflare**  
   - Submit your bot’s key directory URL in the Cloudflare dashboard under **Verified Bots**.  
   - Approval takes about a week. Once verified, your bot is whitelisted.

4. **Sign Your Requests**  
   - After verification, sign requests using the defined protocol (IETF draft).  
   - Recommended components to sign: `@authority` or derived headers from the HTTP Message Signatures spec.

## **💡 Why This Matters**  
- Prevents impersonation: Ensures only your bot can send authenticated requests.  
- Enhances security: Uses modern cryptographic standards (Ed25519).  
- Compliance: Follows active IETF drafts for HTTP message signing.

## **🚀 Ready to Get Started?**  
If you run automated services, this method keeps your requests secure and trustworthy. Check out Cloudflare’s full guide **[here](https://developers.cloudflare.com/fundamentals/get-started/web-bot-auth/)** and get your bot verified.  

Would you implement this for your bots? Let’s discuss below! ⬇️

